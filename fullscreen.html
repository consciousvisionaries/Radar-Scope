<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="refresh" content="60">

<style>
   

.city-highlighted {
  color: #ff0; /* Highlight color */
}

  body, html {
    margin: 0;
    padding: 0;
    height: 100%;
    display: flex;
    background-color: black;
    color: #0f0;
    font-family: monospace;
    overflow: hidden;
  }
  #feed {
  width: 33.33%;
  height: 100vh;
  overflow: hidden;
  font-size: 12px;
  padding: 20px;
  box-sizing: border-box;
  padding-top: 50px; /* Add some padding to the bottom */
  padding-bottom: 100px; /* Add some padding to the bottom */
}

  #radarContainer {

    flex-grow: 1;
    display: flex;
    justify-content: center;
    align-items: center;
  }


#radar {
    position: relative;
    height: 99vh;
    width: 99vh;
    border-radius: 50%;
  }
  #sweep {
  position: absolute;
  width: 100%;
  height: 100%;
  border-radius: 50%;
  /* Define a conic-gradient with a sharp leading edge that fades out */
  background: conic-gradient(
    rgba(0, 255, 0, 0.0) 0%,
    rgba(0, 255, 0, .7) 25%, /* Start of the main beam */
    rgba(0, 255, 0, 0.4) 15%, /* Begin fading after the main beam */
    rgba(0, 255, 0, 0.0) 0% /* Fully faded */
  );
  animation: sweep 4s linear infinite;
}

  .city {
    transition: opacity 1s ease-out; /* Smooth transition for fading to complete invisibility */
    opacity: 0; /* Start invisible */
  }
  .city {
    position: absolute;
    width: 15px;
    height: 15px;
    border-radius: 50%;
    background-color: #ff0;
    transform: translate(-50%, -50%);
  }
 .label {
    position: absolute;
    color: #ff0;
    font-size: 12px;
    white-space: nowrap;
    text-shadow: 1px 1px 1px #000;
    transition: opacity 1s ease-out, font-size 0.5s ease-out; /* Added font-size transition */
}

.city.highlighted {
    width: 30px;
    height: 30px;}


@keyframes sweep {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
}

  .circle {
  position: absolute;
  border: 1px dashed #ff0;
  border-radius: 50%;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
}

.line {
  position: absolute;
  width: 2px;
  height: 100%; /* Adjusted height to extend the crosshair lines beyond the radar */
  background-color: #ff0;
  top: 0%; /* Position at the center vertically */
  left: 50%; /* Position at the center horizontally */
}


.heading-container {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  display: flex;
  justify-content: center;
  align-items: center;
}

.heading {
  position: absolute;
  color: #ff0;
  font-size: 6px;
  transform-origin: 50% 100%;
}

.heading:nth-child(1) {
  transform: rotate(0deg) translateX(-50%); top: 0; }

</style>
</head>
<body>
    <div id="feed">Major Cities:<p></p><p></p></div>
<div id="radarContainer">
    <div id="radar">
      <div id="sweep"></div>
      <!-- Headings -->
     <div class="heading-container">
        <div class="heading">360°</div>
        <div class="heading">90°</div>
        <div class="heading">180°</div>
        <div class="heading">270°</div>
        <div class="heading">North Pole</div> 
      </div>
      <!-- Add inner circles -->
      <div class="circle" style="width: 85%; height: 85%;"></div>
      <div class="circle" style="width: 60%; height: 60%;"></div>
      <div class="circle" style="width: 35%; height: 35%;"></div>
      <div class="circle" style="width: 10%; height: 10%;"></div>
      <!-- Add crosshairs -->
      <div class="line" style="transform: rotate(0deg);"></div>
      <div class="line" style="transform: rotate(45deg);"></div>
      <div class="line" style="transform: rotate(90deg);"></div>
      <div class="line" style="transform: rotate(135deg);"></div>
      <div class="line" style="transform: rotate(180deg);"></div>
      <div class="line" style="transform: rotate(225deg);"></div>
      <div class="line" style="transform: rotate(270deg);"></div>
      <div class="line" style="transform: rotate(315deg);"></div>
    </div>
     
  </div>
  
<script>
const cities = [
  { name: "New York", latitude: 40.7128, longitude: -74.0060 }, // 0°
  { name: "London", latitude: 51.5074, longitude: -0.1278 }, // 45°
  { name: "Tokyo", latitude: 35.6895, longitude: 139.6917 }, // 90°
  { name: "Sydney", latitude: -33.8688, longitude: 151.2093 }, // 135°
  { name: "Moscow", latitude: 55.7558, longitude: 37.6173 }, // 180°
  { name: "Mexico City", latitude: 19.4326, longitude: -99.1332 }, // 225°
  { name: "Cape Town", latitude: -33.9249, longitude: 18.4241 }, // 270°
  { name: "Rio de Janeiro", latitude: -22.9068, longitude: -43.1729 } // 315°
];





const radar = document.getElementById('radar');
const feed = document.getElementById('feed');

function plotCities() {
  const radarRadius = radar.offsetWidth / 2;
  cities.forEach(city => {
    const angleRadians = Math.atan2(city.latitude, city.longitude) + Math.PI / 2; // Adjust for radar's 0 at top
    const distanceFromCenter = radarRadius * (1 - Math.abs(city.latitude) / 90); // Simplify for demo
    const x = radarRadius + distanceFromCenter * Math.cos(angleRadians);
    const y = radarRadius + distanceFromCenter * Math.sin(angleRadians);

    // City Marker
    const marker = document.createElement('div');
    marker.className = 'city';
    marker.style.left = `${x}px`;
    marker.style.top = `${y}px`;
    radar.appendChild(marker);

    // City Label
    const label = document.createElement('div');
    label.className = 'label';
    label.textContent = city.name;
    label.style.left = `${x +20}px`;
    label.style.top = `${y + 20}px`; // Offset for visibility
    radar.appendChild(label);

    // Store for animation
    city.marker = marker;
    city.label = label;
  });
}

function updateFeed() {
  cities.forEach(city => {
    feed.innerHTML += `${city.name},<br> (${city.latitude.toFixed(2)}, ${city.longitude.toFixed(2)})<br>`;
  });
}

let sweepAngle = 0;
let lastUpdateTime = Date.now();





function animateRadar() {
  const now = Date.now();
  const deltaTime = now - lastUpdateTime;
  sweepAngle += (deltaTime / 4000) * 360; // Adjust based on actual time elapsed
  sweepAngle %= 360; // Keep sweepAngle within 0-360 degrees
  lastUpdateTime = now;

  cities.forEach(city => {
    const angleRadians = Math.atan2(city.latitude, city.longitude) + Math.PI / 2;
    const cityAngle = (angleRadians * (180 / Math.PI) + 360) % 360;

    let adjustedSweepAngle = sweepAngle + 11.25; // Adjust sweep angle by 45 degrees
    adjustedSweepAngle %= 360; // Ensure within 0-360 degrees

    let deltaAngle = Math.abs(adjustedSweepAngle - cityAngle);
    deltaAngle = deltaAngle > 180 ? 360 - deltaAngle : deltaAngle;

    // Determine if the city should be highlighted based on the sweep angle
    if (deltaAngle < 5 && !city.highlightStarted) {

      city.marker.style.opacity = 1;
      city.label.style.opacity = 1;
      city.highlightStarted = true; // Mark highlight start

        


          // Add city name to feed
          feed.innerHTML += `${city.name} (${city.latitude.toFixed(2)}, ${city.longitude.toFixed(2)})<br>`;
      
      // Schedule fade out after 0.25 seconds
      setTimeout(() => {

        city.marker.style.transition = 'opacity 1s ease-out';
        city.label.style.transition = 'opacity 1s ease-out';
        city.marker.style.opacity = 1;
        city.label.style.opacity = 1;

      }, 250);

      // Reset state after 0.5 seconds
      setTimeout(() => {
        city.highlightStarted = false;
        city.marker.style.transition = 'opacity 1s ease-out';
        city.label.style.transition = 'opacity 1s ease-out';
        city.marker.style.opacity = 0;
        city.label.style.opacity = 0;
      }, 2000);
    }
  });

  requestAnimationFrame(animateRadar);
}





document.addEventListener('DOMContentLoaded', () => {
    plotCities();
  updateFeed();
  animateRadar();
  const feed = document.getElementById('feed');

  function scrollFeedToBottom() {
    feed.scrollTop = feed.scrollHeight - feed.clientHeight;
  }

  // Check for overflow and scroll to bottom when it occurs
  feed.addEventListener('scroll', () => {
    if (feed.scrollTop + feed.clientHeight >= feed.scrollHeight) {
      feed.style.overflowY = 'auto'; // Enable auto scroll
    } else {
      feed.style.overflowY = 'hidden'; // Disable auto scroll
    }
  });

  // Scroll to bottom when content changes
  const observer = new MutationObserver(scrollFeedToBottom);
  observer.observe(feed, { childList: true, subtree: true });

  // Initial scroll to bottom
  scrollFeedToBottom();
});

</script>
</body>
</html>
